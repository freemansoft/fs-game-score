# fs_game_score

I wanted a scoring app for game night. At around the same time, I was looking for a reason to push to actually use an LLM to do the heavy lifting for app development. This project is the result.

The end result is a multi-platform Flutter app, fs_game_score that can be found on GitHub.  This is a generic game scoring app created almost completely using VSCode's copilot agent mode with virtually zero hand coding. There were many AI agent prompts with **a lot** of undo/redo. The application has been tested on Android, IOS, Chrome, macOS, and Windows 11.

Lessons learned.

1. It helps if you know what libraries you want to use. That lets you direct the copilot to the most up-to-date or best practice libraries. I knew I wanted to use Riverpod 3.x and that I needed something beyond the default Flutter table. I prompted the LLM to add the libraries I wanted and then built on top of that because the pubspec.yaml was in context for my prompts. Copilot only knows the code it knows, and there is more older code out there than code using newer libraries.
2. I fought a lot with the data table behavior for the score sheet. There were cases where the content was too big for the cell, or the scrolling behavior wasn't right. Going out and finding the generally recommended library and having CoPilot add that library cut out days of troubleshooting.
3. The LLM agent tends to generate long functions or methods when building the UI layout. I wanted smaller, discrete components. I needed to either specifically prompt to build the components or created prompts telling the Agent to extract the code from the scoring table or other layouts into their own components.
4. The agent LLM creates large amounts of semi-organized code. I had to provide guidance for code organization: which code got its own files, and the folder organization for code files.
5. I was deliberate about model classes and what they contained. I wanted scope management with cases where I wanted to retain state for various pieces of data. There was a fair amount of trial and error when adding features like the "new game" panel to make sure things didn't get completely erased when I added the column locking controls or reset player names.
6. Partitioning the reactive pieces took work. I used Riverpod, which provides an opinionated model for state and for reactive widget updates.
7. The LLM created long pieces of code. I sometimes iterated several times to break that code apart to make it more testable or maintainable. This is similar to one of the items above.
8. Riverpod reactive style code was finicky because the generated notifiers, scope or data objects didn't handle the corner cases. Describing the broken behavior to CoPilot was enough to fix the problem about 50% of the time.
9. Sometimes I got blocked because I accepted code that appeared to be working to realize later that I wanted a different structure for the next round of changes.
10. I wanted the code to be testable and for the Flutter widgets to be findable by ID. I created prompts to get IDs added everywhere and found that I had to make decisions that required an understanding of Flutter testing to get the best answer. Most of my widgets were wrappers for the actual field or text that the component represented. This created tension over where we wanted the `key` to be bound. Some of the components were generated by passing in a `key`. Some were generated supporting a `FieldKey` that was actually set on the wrapped component. I ended up standardizing on a key for the custom component. This meant the actual text or field had to be found in the test by searching for descendants of the ID I knew. The alternative was to pass in two keys or only support the `FieldKey`
11. There were a lot of iterations around state management in order to get the lifespan correct for various Riverpod notifiers and `ref.watch` `ref.read` operations.
12. Adding accessibility support required fiddling with the prompts to get the Semantic objects I wanted. There were a couple of cases where providing the same prompt twice in a row solved my problem. The first one did most of the work, and the 2nd one fixed the broken part.
13. Integration tests: Long dropdowns are not fully visible when pressed on if the number of options is too long. Copilot never offered to scroll to find the item I wanted. Getting the CoPilot to scroll to find the items I was looking for was painful.  It never did generate exactly the code I would have wanted. The code at this time is a bit of a hack where it scrolls by some big amount to force the other end to become visible.
14. Integration tests: Copilot mostly got the field keys right when using finders `byKey`. Sometimes it completely lost the plot when trying to iterate fixes, hallucinating `key` names, especially if they were generated.
15. Integration tests: My custom components had `keys`.  The actual Flutter component we needed to enter data in or validate against was some wrapped component. I had trouble prompting for a solution.
16. Integration tests: Working with component navigation in tests was a lot easier to prompt for once we had a project example. Then it was almost automatic.

## This app

Implements a scorecard for an arbitrary number of players and game _rounds_

Two scorecard types are supported

1. Basic scorecard with individual round scores and player total scores
2. Phase capture plus individual round scores and player total scores _plus_ dropdowns that let you pick a completed phase.  Hovering over the player's total score will show you which phases have been captured (the set of phase dropdown selections)

Notes

1. Player's names can be edited in place in the scoring table.
2. Round scores can be edited in place in the appropriate columns.  Scores will be totaled under the player's name.
3. The "New Game" icon will clear the board scores and optionally the player names for times you want to change the order
4. The "Home" or "Change Scoreboard Type" icon will let you return to the start screen that lets you change the number of players and the data entry types (score & phase)

## Looking to run the working scoring app?

### Option 1

1. Clone this repo.
2. Open the whole repo in VSCode
3. Select the run view on the left hand side
4. Select fs_game_score in the run drop down menu
5. Press the green run button
6. The application will run on an emulator or connected device.

### Option 2

1. Clone this repo.
2. Open the `fs_game_score` directory in VSCode.
3. Run the Flutter application using the debug button or by pressing `F5`
4. The application will run on an emulator or connected device.

## Testing the App

Options

1. Run this with the IDE
2. (Android) Create an apk and downloaded it to a device
   1. Build the package `flutter build apk --target-platform android-arm64`
   2. Share `build/app/outputs/flutter-apk/app-release.apk` to devices.  This can be done by emailing or by pushing the apk to a shared storage and then having the tester downloaded it.
3. Validate the version number on the splash screen. It should match the value in `pubps pec.yaml`.  The version number is set in `pubspec.yaml`.

## Integration tests

Integration tests can't be run against browsers.  Web based integration tests are not supported (2025/07)

The integration tests were generated by copilot and are copilot updated.  You can run them with

```bash
flutter test integration_test/splash_screen_test.dart
flutter test integration_test/score_table_test.dart
```

You can run all of the integration tests in a single command when targeting mobile platforms.

```bash
flutter test integration_test/*_test.dart
```

1. MacOS - can only run tests individually
2. Windows - not tested
3. Linux - not tested
4. Android - Yes
5. iOS - Yes
6. Web - integration test not supported

## Notes

1. Java 21 installations will get an error because this is using gradle 8.10.2 which matches Java 23.
2. I'm on Java 21 matches against gradle 8.5
3. This android build requires at least gradle 8.7.
4. If you go to plugin version 8.8 to work with gradle 8.10.2 you get an ndk version error
5. So we left the "Could not create task generateLockfiles error.

| Java | Gradle (min) | Android Plugin |
| ---- | ------------ | -------------- |
| 21   | 8.4          | 8.3            |
| ??   | 8.6          | 8.4            |
| ??   | 8.7          | 8.5            |
| 22   | 8.7          | 8.6            |
| ??   | 8.9          | 8.7            |
| 23   | 8.10.2       | 8.8            |

1. <https://docs.gradle.org/current/userguide/compatibility.html>
2. <https://developer.android.com/build/releases/gradle-plugin>

## Icons

Android and IOS icons generated using the [appicon.co App Icon Generator](https://www.appicon.co/)

## Known Issues

* Locked cells are not legible when the app runs in dark mode
* The disabled color for the phase dropdown isn't quite right. Both light and dark are incorrect.
