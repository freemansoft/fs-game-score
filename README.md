# fs_score_card

I wanted a scoring app for game night. At around the same time, I was looking for a reason to push to actually use an LLM to do the heavy lifting for app development. This project is the result.

The end result is a multi-platform Flutter app, fs_score_card that can be found on GitHub.  This is a generic game scoring app created almost completely using VSCode's copilot agent mode with virtually zero hand coding. There were many AI agent prompts with **a lot** of undo/redo. The application has been tested on Android, IOS, Chrome, macOS, and Windows 11.

## Lessons learned

1. It helps if you know what libraries you want to use. That lets you direct the copilot to the most up-to-date or best practice libraries. I knew I wanted to use Riverpod 3.x and that I needed something beyond the default Flutter table. I prompted the LLM to add the libraries I wanted and then built on top of that because the pubspec.yaml was in context for my prompts. Copilot only knows the code it knows, and there is more older code out there than code using newer libraries.
2. I fought a lot with the data table behavior for the score sheet. There were cases where the content was too big for the cell, or the scrolling behavior wasn't right. Going out and finding the generally recommended library and having CoPilot add that library cut out days of troubleshooting.
3. The LLM agent tends to generate long functions or methods when building the UI layout. I wanted smaller, discrete components. I needed to either specifically prompt to build the components or created prompts telling the Agent to extract the code from the scoring table or other layouts into their own components.
4. The agent LLM creates large amounts of semi-organized code. I had to provide guidance for code organization: which code got its own files, and the folder organization for code files.
5. I was deliberate about model classes and what they contained. I wanted scope management with cases where I wanted to retain state for various pieces of data. There was a fair amount of trial and error when adding features like the "new game" panel to make sure things didn't get completely erased when I added the column locking controls or reset player names.
6. Partitioning the reactive pieces took work. I used Riverpod, which provides an opinionated model for state and for reactive widget updates.
7. The LLM created long pieces of code. I sometimes iterated several times to break that code apart to make it more testable or maintainable. This is similar to one of the items above.
8. Riverpod reactive style code was finicky because the generated notifiers, scope or data objects didn't handle the corner cases. Describing the broken behavior to CoPilot was enough to fix the problem about 50% of the time.
9. Sometimes I got blocked because I accepted code that appeared to be working to realize later that I wanted a different structure for the next round of changes.
10. I wanted the code to be testable and for the Flutter widgets to be findable by ID. I created prompts to get IDs added everywhere and found that I had to make decisions that required an understanding of Flutter testing to get the best answer. Most of my widgets were wrappers for the actual field or text that the component represented. This created tension over where we wanted the `key` to be bound. Some of the components were generated by passing in a `key`. Some were generated supporting a `FieldKey` that was actually set on the wrapped component. I ended up standardizing on a key for the custom component. This meant the actual text or field had to be found in the test by searching for descendants of the ID I knew. The alternative was to pass in two keys or only support the `FieldKey`
11. There were a lot of iterations around state management in order to get the lifespan correct for various Riverpod notifiers and `ref.watch` `ref.read` operations.
12. Adding accessibility support required fiddling with the prompts to get the Semantic objects I wanted. There were a couple of cases where providing the same prompt twice in a row solved my problem. The first one did most of the work, and the 2nd one fixed the broken part.
13. Integration tests: Long dropdowns are not fully visible when pressed on if the number of options is too long. Copilot never offered to scroll to find the item I wanted. Getting the CoPilot to scroll to find the items I was looking for was painful.  It never did generate exactly the code I would have wanted. The code at this time is a bit of a hack where it scrolls by some big amount to force the other end to become visible.
14. Integration tests: Copilot mostly got the field keys right when using finders `byKey`. Sometimes it completely lost the plot when trying to iterate fixes, hallucinating `key` names, especially if they were generated.
15. Integration tests: My custom components had `keys`.  The actual Flutter component we needed to enter data in or validate against was some wrapped component. I had trouble prompting for a solution.
16. Integration tests: Working with component navigation in tests was a lot easier to prompt for once we had a project example. Then it was almost automatic.
17. This uses Riverpod which I sort of understand.  There have been a couple times AI made changes to the Riverpod code that broke the app. Often I didn't know enough to describe how to fix it so I'd iterate with the Agent having it "fix".  A couple times this came to a bad result and I'd rollback and try again. This was especially true when I converted the Notifier for a `List<Player>` to a `Players` object that contained a `List<Player>`.  If it breaks again I may not understand why.
18. Construction was often done closest to use.  This makes mocking or other types of things like a global initializer difficult and things like game restore from preferences difficult. _not yet impemented at the time of this note_

## This app

Implements a scorecard for an arbitrary number of players and game _rounds_

Two scorecard types are supported

1. Basic scorecard with individual round scores and player total scores
2. Phase capture plus individual round scores and player total scores _plus_ dropdowns that let you pick a completed phase.  Hovering over the player's total score will show you which phases have been captured (the set of phase dropdown selections)

Preferences

1. The game configuration is saved to SharedPreferneces when a game is started
2. The game configuration is loaded as the default when showing the spalsh screen to start a new game

Notes

1. Player's names can be edited in place in the scoring table.
2. Round scores can be edited in place in the appropriate columns.  Scores will be totaled under the player's name.
3. The "New Game" icon will clear the board scores and optionally the player names for times you want to change the order
4. The "Home" or "Change Score Card Type" icon will let you return to the start screen that lets you change the number of players and the data entry types (score & phase)

## Looking to run the working scoring app?

### Option 1

1. Clone this repo.
2. Open the whole repo in VSCode
3. Select the run view on the left hand side
4. Select fs_score_card in the run drop down menu
5. Press the green run button
6. The application will run on an emulator or connected device.

### Option 2

1. Clone this repo.
2. Open the `fs_score_card` directory in VSCode.
3. Run the Flutter application using the debug button or by pressing `F5`
4. The application will run on an emulator or connected device.

## Testing the App

### Android options

Android apks end up bult in two places. [Stack Overflow](https://stackoverflow.com/questions/62910148/flutter-what-is-the-difference-between-the-apk-release-directory-and-flutter-ap)

* `build/app/outputs/apk` Including app name and version in the `apk` filename.
  * `build/app/outputs/apk/releasefs_score_card-v<version>-release.apk`
  * `build/app/outputs/apk/debug/fs_score_card-v<version>-debug.apk`
* `build/app/outputs/flutter-apk` Generic apk without the app name and version in the `apk` filename. These include sha1 files.
  * `build/app/outputs/flutter-apk/apk-release.apkk`
  * `build/app/outputs/flutter-apk/app-debug.ap`

1. Run this on a connected iOS or Android device using the IDE
2. (Android) Create an apk and downloaded it to a device
   1. Build the android arm64 package. Including the `android-arm64` makes it a single target binary and drops the size from 23MB to 8MB
      1. `flutter build apk --target-platform android-arm64`
      2. including the `android-arm64` makes it a single target binary and drops the size from 23MB to 8MB
   2. Share `build/app/outputs/apk/release/fs_score_card-v<release>-release.apk` to devices.  This can be done by emailing or by pushing the apk to a shared storage
      1. You can share the generic named apk from `build/outputs/flutter-apk/app-release.apk` There should be an associated `sha` file there.
3. (ios) This is complicated by the Apple store

Validate the version number on the splash screen. It should match the value in `pubps pec.yaml`.  The version number is set in `pubspec.yaml`.

### Web options

1. Run this locally using the IDE and a web browser like Chrome
2. Create a distributable web package that can be distributed for people to web test locally
   1. Build the package `flutter build web` or `flutter build web --release`
   2. create a zip file of `build/web`
   3. Share the zip. They can unzip it and put the contents of the `web` folder in the web server docroot. The `web` folder should not be part of the path.

## Integration tests

Integration tests can't be run against browsers.  Web based integration tests are not supported (2025/07)

The integration tests were generated by copilot and are copilot updated.  You can run them with

```bash
flutter test integration_test/splash_screen_test.dart
flutter test integration_test/score_table_test.dart
```

You can run all of the integration tests in a single command when targeting mobile platforms.

```bash
flutter test integration_test/*_test.dart
```

1. MacOS - can only run tests individually
2. Windows - not tested
3. Linux - not tested
4. Android - Yes
5. iOS - Yes
6. Web - integration test not supported

## Notes

1. Java 21 installations will get an error because this is using gradle 8.10.2 which matches Java 23.
2. I'm on Java 21 matches against gradle 8.5
3. This android build requires at least gradle 8.7.
4. If you go to plugin version 8.8 to work with gradle 8.10.2 you get an ndk version error
5. So we left the "Could not create task generateLockfiles error.

| Java | Gradle (min) | Android Plugin |
| ---- | ------------ | -------------- |
| 21   | 8.4          | 8.3            |
| ??   | 8.6          | 8.4            |
| ??   | 8.7          | 8.5            |
| 22   | 8.7          | 8.6            |
| ??   | 8.9          | 8.7            |
| 23   | 8.10.2       | 8.8            |

1. <https://docs.gradle.org/current/userguide/compatibility.html>
2. <https://developer.android.com/build/releases/gradle-plugin>

## Icons

Android and IOS icons generated using the [appicon.co App Icon Generator](https://www.appicon.co/)

## creating a release

* Create a tag, update the pubspec.yaml update the CHANGELOG to add the new release
  * `bash tag-push.sh --version <major.minor.patch> --force`
* Edit the CHANGELOG.md updating the new section to include the changes you want
* Commit the changelog and the pubspec.yaml and push the tags, changelog and pubspec.yaml to the remote server
  * `bash tag-push.sh --version <major.minor.patch> --force --push`

## Known Issues

* The disabled color for the phase dropdown isn't quite right. Both light and dark are incorrect.

## Tag management hints

In case you need to manually update release tags

* Create a local tag `git tag 1.1.0+1`
* Delete a local tag `git tag -d 1.1.0+1`
* Push tags to remote `git push origin --tags`
* Delete a remote tag `git push origin --delete 1.1.0+1`
  * Deleting a remote tag will **not** work if there is a release tied to the tag
